# --- START: tests/test_integration.py ---
import unittest
import os
import shutil
import tempfile
import json
import git # Import git for Repo object simulation and exceptions
from unittest.mock import patch, MagicMock, PropertyMock, call
from typing import List, Dict, Optional, Any

# Ensure imports work correctly assuming tests are run from the project root
# Adjust path if necessary based on your test runner setup
import sys
if '.' not in sys.path:
    sys.path.append('.') # Add project root if needed

# Import core components
# Mock ConfigManager before other imports that might use it implicitly
mock_config_manager_instance_integration = MagicMock()
mock_config_manager_class_integration = MagicMock(return_value=mock_config_manager_instance_integration)
sys.modules['core.config_manager'] = MagicMock(ConfigManager=mock_config_manager_class_integration)

# --- Mock LLM Interface dependencies BEFORE importing LLMInterface ---
# Mock google.generativeai used by llm_interface
mock_genai_integration = MagicMock()
sys.modules['google.generativeai'] = mock_genai_integration
sys.modules['google.generativeai.types'] = MagicMock()
# Mock google.api_core exceptions used by llm_interface
mock_api_exceptions_integration = MagicMock()
sys.modules['google.api_core'] = MagicMock(exceptions=mock_api_exceptions_integration)
# It's important these mocks are in place *before* llm_interface is imported below

from core.github_handler import GitHubHandler
from core.llm_interface import LLMInterface
from core.file_processor import FileProcessor
from core.exceptions import GitHubError, LLMError, ParsingError, FileProcessingError, ConfigurationError
# from core.config_manager import ConfigManager # No need to import mocked version directly


# Note: Integration tests involving GUI elements (PySide6) often require
# specific test runners or frameworks like pytest-qt to handle the event loop
# and widget interactions. This example focuses on integrating the core logic flow.

# We can simulate the workflow without needing the actual GUI/Threads.
class TestCoreIntegration(unittest.TestCase):
    """
    Integration tests for the core logic workflow (excluding direct GUI interaction).
    Mocks external dependencies like Git remote operations and LLM API calls.
    Uses a temporary directory for local file operations and a simulated Git repo.
    """

    # Constants for test files and content
    _INITIAL_FILE_REL_PATH: str = "module/main.py"
    _INITIAL_FILE_CONTENT: str = "print('Hello from initial file!')"
    _UPDATED_FILE_CONTENT: str = "print('Hello from LLM updated file!')\n# New line added"
    _NEW_FILE_REL_PATH: str = "data/new_data.txt"
    _NEW_FILE_CONTENT: str = "This is a new file generated by the LLM."
    _MOCK_URL: str = "https://example.com/user/repo.git" # Corrected URL format
    _DUMMY_API_KEY: str = "dummy_api_key_123" # Used for mocking config only
    _MOCK_MODEL_NAME: str = "mock-gemini-model"
    _COMMIT_MSG: str = "Apply LLM updates"
    _REMOTE_NAME: str = "origin"
    _BRANCH_NAME: str = "main"

    def setUp(self: 'TestCoreIntegration') -> None:
        """
        Sets up a temporary directory, initialises a real Git repository within it,
        creates an initial file, and initialises core component instances with mocks.
        """
        # Create temporary directory for the test run
        self.test_dir = tempfile.mkdtemp()
        self.local_repo_path = os.path.join(self.test_dir, "repo")

        # Initialise a *real* git repo in the temp dir for realistic local operations
        self.repo = git.Repo.init(self.local_repo_path)

        # Create and commit an initial file
        self.initial_file_abs_path = os.path.join(self.local_repo_path, self._INITIAL_FILE_REL_PATH)
        os.makedirs(os.path.dirname(self.initial_file_abs_path), exist_ok=True)
        with open(self.initial_file_abs_path, 'w', encoding='utf-8') as f:
            f.write(self._INITIAL_FILE_CONTENT)
        self.repo.index.add([self._INITIAL_FILE_REL_PATH])
        self.repo.index.commit("Initial commit")

        # Add a dummy remote for push tests (won't actually connect)
        self.repo.create_remote(self._REMOTE_NAME, url="https://example.com/dummy/push/target.git") # Corrected URL format

        # Configure the mocked ConfigManager instance centrally
        self.config_manager = mock_config_manager_instance_integration
        self.config_manager.reset_mock() # Ensure clean state for each test
        self.config_manager.getEnvVar.side_effect = self._mock_get_env_var
        self.config_manager.getConfigValue.side_effect = self._mock_get_config_value
        self.config_manager.getConfigValueInt.side_effect = self._mock_get_config_value_int
        self.config_manager.getConfigValueFloat.side_effect = self._mock_get_config_value_float

        # Initialise core components, passing the mocked ConfigManager
        self.github_handler = GitHubHandler()
        # LLMInterface instantiation relies on the sys.modules mocks for google.generativeai being active
        self.llm_interface = LLMInterface(configManager=self.config_manager)
        self.file_processor = FileProcessor()

        # Patch loggers for all core modules used to suppress output during tests
        self.patchers = {
            'gh': patch('core.github_handler.logger', MagicMock()),
            'llm': patch('core.llm_interface.logger', MagicMock()),
            'fp': patch('core.file_processor.logger', MagicMock()),
            # 'cm': patch('core.config_manager.logger', MagicMock()), # Mocked via sys.modules approach
            # '__main__': patch('__main__.logger', MagicMock(), create=True) # Avoid if __main__ not relevant
        }
        # Start required patchers
        self.mock_loggers = {name: patcher.start() for name, patcher in self.patchers.items()}


    def tearDown(self: 'TestCoreIntegration') -> None:
        """Cleans up the temporary directory and stops patching."""
        # Stop all patchers
        for patcher in self.patchers.values():
            patcher.stop()
        # Remove the temporary directory
        shutil.rmtree(self.test_dir)

    # --- Mock ConfigManager Helpers ---
    def _mock_get_env_var(self, key: str, defaultValue: Optional[str] = None, required: bool = False) -> Optional[str]:
        """Simulates retrieving environment variables."""
        if key == 'GEMINI_API_KEY':
            return self._DUMMY_API_KEY
        if required and defaultValue is None:
            # Simulate raising error if a required env var used in tests is missing
            raise ConfigurationError(f"Mock missing required env var: {key}")
        return defaultValue

    def _mock_get_config_value(self, section: str, key: str, fallback: Optional[str] = None, required: bool = False) -> Optional[str]:
        """Simulates retrieving string config values."""
        config_map = {
            'General': {
                'DefaultLlmModel': self._MOCK_MODEL_NAME,
                'ExpectedOutputFormat': 'json',
                'DefaultCloneDir': os.path.join(self.test_dir, 'cloned_repos') # Use temp dir
            },
            'GitHub': {
                'DefaultRemoteName': self._REMOTE_NAME,
                'DefaultBranchName': self._BRANCH_NAME,
                'DefaultCommitMessage': 'LLM Auto-Update via Colonol Code'
            },
            'Logging': { # Provide some defaults for logging setup if tested implicitly
                'FileLogLevel': 'INFO',
                'LogDirectory': os.path.join(self.test_dir, 'logs'),
                'LogFileName': 'test_app_log.log',
                'GuiLogLevel': 'INFO'
            },
            'LLM': {} # Add LLM section for safety settings if needed
        }
        # Add safety settings defaults (e.g., None)
        safety_keys = [
            'HarmCategoryHarassmentThreshold', 'HarmCategoryHateSpeechThreshold',
            'HarmCategorySexuallyExplicitThreshold', 'HarmCategoryDangerousContentThreshold'
        ]
        for skey in safety_keys:
             if (section, key) == ('LLM', skey):
                  return None # Simulate safety keys not being set

        value = config_map.get(section, {}).get(key)
        if value is not None:
            return value
        if required and fallback is None:
            raise ConfigurationError(f"Mock missing required config: [{section}] {key}")
        return fallback

    def _mock_get_config_value_int(self, section: str, key: str, fallback: Optional[int] = None, required: bool = False) -> Optional[int]:
        """Simulates retrieving integer config values."""
        config_map_int = {
            'LLM': {
                'MaxOutputTokens': 8192,
                'MaxCharsPerFileInPrompt': 10000, # Default large value for most tests
                'MaxTokensPerFileInPrompt': 0 # Default disabled for most tests
            }
        }
        # Return directly from map if present
        value = config_map_int.get(section, {}).get(key)
        if value is not None:
            return value # Assume value is already int for simplicity here

        if required and fallback is None:
            raise ConfigurationError(f"Mock missing required int config: [{section}] {key}")
        return fallback # Return the provided fallback type (int or None)

    def _mock_get_config_value_float(self, section: str, key: str, fallback: Optional[float] = None, required: bool = False) -> Optional[float]:
        """Simulates retrieving float config values."""
        config_map_float = {
            'LLM': {
                'Temperature': 0.7
            }
        }
         # Return directly from map if present
        value = config_map_float.get(section, {}).get(key)
        if value is not None:
             return value # Assume value is already float

        if required and fallback is None:
            raise ConfigurationError(f"Mock missing required float config: [{section}] {key}")
        return fallback


    # --- Integration Test Cases ---

    @patch('core.github_handler.GitHubHandler.cloneRepository') # Still mock initial clone/load for simplicity
    @patch('core.llm_interface.LLMInterface.queryLlmApi')      # Mock LLM call
    @patch('core.github_handler.GitHubHandler.updateRepo')     # Mock commit/push action
    def test_full_workflow_success_update_and_new_file(
        self: 'TestCoreIntegration',
        mock_updateRepo: MagicMock,
        mock_queryLlmApi: MagicMock,
        mock_cloneRepository: MagicMock
    ) -> None:
        """
        Tests the complete workflow: load -> list -> read -> prompt -> query LLM -> parse -> save -> commit/push.
        Simulates an LLM response that updates one file and creates a new one.
        Uses the real local Git repo for local file operations (list, read, save, isDirty).
        """
        # --- Arrange: Setup Mocks and Expected Data ---
        # 1. Mock cloneRepository to return the real repo object created in setUp
        mock_cloneRepository.return_value = self.repo

        # 2. Define mock LLM response (updates one file, creates another)
        mock_llm_response_json = {
            self._INITIAL_FILE_REL_PATH: self._UPDATED_FILE_CONTENT,
            self._NEW_FILE_REL_PATH: self._NEW_FILE_CONTENT
        }
        mock_llm_response_text = f"```json\n{json.dumps(mock_llm_response_json, indent=2)}\n```"
        mock_queryLlmApi.return_value = mock_llm_response_text

        # 3. Mock updateRepo (commit/push) response
        mock_updateRepo.return_value = "Changes committed and pushed successfully."

        # --- Act: Simulate Workflow Steps ---
        # 1. Load/Clone Repo (Initial call is mocked)
        repo_loaded = self.github_handler.cloneRepository(self._MOCK_URL, self.local_repo_path)
        mock_cloneRepository.assert_called_once_with(self._MOCK_URL, self.local_repo_path, None, progress_handler=None) # Assuming no progress handler passed here
        self.assertEqual(repo_loaded.working_dir, self.local_repo_path, "Loaded repo path mismatch")

        # 2. List files (Uses real Git repo)
        files = self.github_handler.listFiles(self.local_repo_path)
        self.assertIn(self._INITIAL_FILE_REL_PATH, files, "Initial file not listed")
        selected_files = [self._INITIAL_FILE_REL_PATH] # Simulate selecting the initial file

        # 3. Read file content (Uses real Git repo - NO MOCK NEEDED)
        file_contents: Dict[str, str] = {}
        for f_path in selected_files:
            content = self.github_handler.readFileContent(self.local_repo_path, f_path)
            file_contents[f_path] = content
        self.assertEqual(file_contents[self._INITIAL_FILE_REL_PATH], self._INITIAL_FILE_CONTENT, "Initial file content mismatch")

        # 4. Build Prompt (Uses real implementation with mocked config)
        instruction = "Update the print statement, add a comment, and create a new data file."
        prompt = self.llm_interface.buildPrompt(instruction, file_contents)
        self.assertIn(instruction, prompt, "Instruction missing in prompt")
        self.assertIn(self._INITIAL_FILE_CONTENT, prompt, "File content missing in prompt")
        self.assertIn("```json", prompt, "JSON output format specifier missing in prompt")

        # 5. Query LLM (Mocked)
        # FIX: Call queryLlmApi without apiKey argument
        llm_response = self.llm_interface.queryLlmApi(prompt, self._MOCK_MODEL_NAME)
        mock_queryLlmApi.assert_called_once_with(prompt, self._MOCK_MODEL_NAME) # Check args
        self.assertEqual(llm_response, mock_llm_response_text, "LLM response mismatch")

        # 6. Extract Code Block (Uses real implementation)
        code_block = self.file_processor.extractCodeBlock(llm_response, language='json') # Use mocked config format
        self.assertIsNotNone(code_block, "Code block extraction failed")

        # 7. Parse Structured Output (Uses real implementation)
        parsed_data = self.file_processor.parseStructuredOutput(code_block, format='json') # Use mocked config format
        self.assertEqual(parsed_data, mock_llm_response_json, "Parsed data mismatch")

        # 8. Save Files to Disk (Uses real Git repo in temp dir - NO MOCK NEEDED)
        saved_files = self.file_processor.saveFilesToDisk(self.local_repo_path, parsed_data)
        self.assertCountEqual(saved_files, list(mock_llm_response_json.keys()), "Saved files list mismatch") # Use assertCountEqual for lists

        # --- Assert: Verification after saving (before commit/push) ---
        # Check content of updated file
        updated_file_abs_path = os.path.join(self.local_repo_path, self._INITIAL_FILE_REL_PATH)
        self.assertTrue(os.path.exists(updated_file_abs_path), "Updated file does not exist")
        with open(updated_file_abs_path, 'r', encoding='utf-8') as f:
            self.assertEqual(f.read(), self._UPDATED_FILE_CONTENT, "Updated file content incorrect")

        # Check content of new file
        new_file_abs_path = os.path.join(self.local_repo_path, self._NEW_FILE_REL_PATH)
        self.assertTrue(os.path.exists(new_file_abs_path), "New file does not exist")
        with open(new_file_abs_path, 'r', encoding='utf-8') as f:
            self.assertEqual(f.read(), self._NEW_FILE_CONTENT, "New file content incorrect")

        # 9. Check Dirty Status (Uses real Git repo - NO MOCK NEEDED)
        is_dirty = self.github_handler.isDirty(self.local_repo_path)
        self.assertTrue(is_dirty, "Repository should be dirty after saving changes.")

        # 10. Commit & Push (Mocked)
        update_result = self.github_handler.updateRepo(
            self.local_repo_path, self._COMMIT_MSG, push=True, remoteName=self._REMOTE_NAME, branchName=self._BRANCH_NAME
        )

        # --- Assert: Final Verification ---
        mock_updateRepo.assert_called_once_with(
            self.local_repo_path, self._COMMIT_MSG, push=True, remoteName=self._REMOTE_NAME, branchName=self._BRANCH_NAME, progress_handler=None
        )
        self.assertEqual(update_result, "Changes committed and pushed successfully.", "Final update result mismatch")


    @patch('core.github_handler.GitHubHandler.cloneRepository')
    @patch('core.llm_interface.LLMInterface.queryLlmApi') # Mock LLM call
    @patch('core.github_handler.GitHubHandler.updateRepo') # Mock commit/push action
    def test_workflow_llm_returns_no_changes(
        self: 'TestCoreIntegration',
        mock_updateRepo: MagicMock,
        mock_queryLlmApi: MagicMock,
        mock_cloneRepository: MagicMock
    ) -> None:
        """
        Tests workflow where LLM response indicates no files need changes (empty JSON object).
        Ensures no files are saved and commit/push doesn't happen due to no changes.
        """
        # --- Arrange ---
        mock_cloneRepository.return_value = self.repo
        mock_llm_response_text = "```json\n{}\n```" # Empty JSON object
        mock_queryLlmApi.return_value = mock_llm_response_text

        # --- Act ---
        repo_loaded = self.github_handler.cloneRepository(self._MOCK_URL, self.local_repo_path)
        selected_files = [self._INITIAL_FILE_REL_PATH]
        file_contents = {f: self.github_handler.readFileContent(self.local_repo_path, f) for f in selected_files}
        instruction = "Review this code but make no changes."
        prompt = self.llm_interface.buildPrompt(instruction, file_contents)
        # FIX: Call queryLlmApi without apiKey argument
        llm_response = self.llm_interface.queryLlmApi(prompt, self._MOCK_MODEL_NAME)
        code_block = self.file_processor.extractCodeBlock(llm_response, language='json')
        parsed_data = self.file_processor.parseStructuredOutput(code_block, format='json')

        # --- Assert ---
        self.assertEqual(parsed_data, {}, "Parsed data should be an empty dictionary")

        # Attempt to save (should do nothing gracefully if data is empty)
        saved_files = self.file_processor.saveFilesToDisk(self.local_repo_path, parsed_data)
        self.assertEqual(saved_files, [], "No files should have been saved")

        # Verify file content remains unchanged
        with open(self.initial_file_abs_path, 'r', encoding='utf-8') as f:
            self.assertEqual(f.read(), self._INITIAL_FILE_CONTENT, "Initial file content should be unchanged")

        # Verify repo is not dirty
        self.assertFalse(self.github_handler.isDirty(self.local_repo_path), "Repository should be clean as no changes were saved.")

        # Verify updateRepo is called but returns "No changes detected." because repo isn't dirty
        with patch.object(self.github_handler, 'isDirty', return_value=False) as mock_isDirty_in_update:
            update_result = self.github_handler.updateRepo(self.local_repo_path, self._COMMIT_MSG, push=True)
            self.assertEqual(update_result, "No changes detected.", "updateRepo should report no changes")
            mock_isDirty_in_update.assert_called_once_with(self.local_repo_path)

        # Ensure the main updateRepo mock (for push) was NOT called
        mock_updateRepo.assert_not_called()


    @patch('core.github_handler.GitHubHandler.cloneRepository')
    @patch('core.llm_interface.LLMInterface.queryLlmApi')
    def test_workflow_llm_error_handling(
        self: 'TestCoreIntegration',
        mock_queryLlmApi: MagicMock,
        mock_cloneRepository: MagicMock
    ) -> None:
        """Tests workflow stops correctly if the LLM query fails with an LLMError."""
        # --- Arrange ---
        mock_cloneRepository.return_value = self.repo
        llm_error_message = "API rate limit exceeded"
        mock_queryLlmApi.side_effect = LLMError(llm_error_message)

        # --- Act ---
        repo_loaded = self.github_handler.cloneRepository(self._MOCK_URL, self.local_repo_path)
        selected_files = [self._INITIAL_FILE_REL_PATH]
        file_contents = {f: self.github_handler.readFileContent(self.local_repo_path, f) for f in selected_files}
        instruction = "Do something that will cause an LLM error."
        prompt = self.llm_interface.buildPrompt(instruction, file_contents)

        # --- Assert ---
        # Expect LLMError to be raised when querying
        with self.assertRaisesRegex(LLMError, llm_error_message):
            # FIX: Call queryLlmApi without apiKey argument
            self.llm_interface.queryLlmApi(prompt, self._MOCK_MODEL_NAME)

        # Verify file content remains unchanged
        with open(self.initial_file_abs_path, 'r', encoding='utf-8') as f:
            self.assertEqual(f.read(), self._INITIAL_FILE_CONTENT, "File content should be unchanged after LLM error")

        # Verify repo is not dirty
        self.assertFalse(self.github_handler.isDirty(self.local_repo_path), "Repo should be clean after LLM error")


    @patch('core.github_handler.GitHubHandler.cloneRepository')
    @patch('core.llm_interface.LLMInterface.queryLlmApi')
    def test_workflow_parsing_error_invalid_json(
        self: 'TestCoreIntegration',
        mock_queryLlmApi: MagicMock,
        mock_cloneRepository: MagicMock
    ) -> None:
        """Tests workflow stops correctly if LLM response contains invalid JSON."""
        # --- Arrange ---
        mock_cloneRepository.return_value = self.repo
        mock_llm_response_text = "```json\n{\n  \"file.py\": \"print('hello')\",\n  \"invalid\": \n}\n```" # Invalid JSON
        mock_queryLlmApi.return_value = mock_llm_response_text

        # --- Act ---
        repo_loaded = self.github_handler.cloneRepository(self._MOCK_URL, self.local_repo_path)
        selected_files = [self._INITIAL_FILE_REL_PATH]
        file_contents = {f: self.github_handler.readFileContent(self.local_repo_path, f) for f in selected_files}
        instruction = "Generate invalid JSON."
        prompt = self.llm_interface.buildPrompt(instruction, file_contents)
        # FIX: Call queryLlmApi without apiKey argument
        llm_response = self.llm_interface.queryLlmApi(prompt, self._MOCK_MODEL_NAME)
        code_block = self.file_processor.extractCodeBlock(llm_response, language='json')

        # --- Assert ---
        self.assertIsNotNone(code_block)
        # Expect ParsingError (wrapping JSONDecodeError) when parsing
        with self.assertRaisesRegex(ParsingError, "Invalid JSON detected"):
            self.file_processor.parseStructuredOutput(code_block, format='json')

        # Verify file content remains unchanged
        with open(self.initial_file_abs_path, 'r', encoding='utf-8') as f:
            self.assertEqual(f.read(), self._INITIAL_FILE_CONTENT, "File content should be unchanged after parsing error")

        # Verify repo is not dirty
        self.assertFalse(self.github_handler.isDirty(self.local_repo_path), "Repo should be clean after parsing error")


    @patch('core.github_handler.GitHubHandler.cloneRepository')
    @patch('core.llm_interface.LLMInterface.queryLlmApi')
    def test_workflow_parsing_error_unsafe_path(
        self: 'TestCoreIntegration',
        mock_queryLlmApi: MagicMock,
        mock_cloneRepository: MagicMock
    ) -> None:
        """Tests workflow stops correctly if LLM response contains an unsafe file path."""
        # --- Arrange ---
        mock_cloneRepository.return_value = self.repo
        mock_llm_response_json = {
            "../unsafe_file.txt": "malicious content",
            self._INITIAL_FILE_REL_PATH: self._UPDATED_FILE_CONTENT
        }
        mock_llm_response_text = f"```json\n{json.dumps(mock_llm_response_json, indent=2)}\n```"
        mock_queryLlmApi.return_value = mock_llm_response_text

        # --- Act ---
        repo_loaded = self.github_handler.cloneRepository(self._MOCK_URL, self.local_repo_path)
        # FIX: Call queryLlmApi without apiKey argument
        llm_response = self.llm_interface.queryLlmApi("prompt", self._MOCK_MODEL_NAME)
        code_block = self.file_processor.extractCodeBlock(llm_response, language='json')

        # --- Assert ---
        self.assertIsNotNone(code_block)
        # Expect ParsingError due to unsafe path key
        with self.assertRaisesRegex(ParsingError, "key '../unsafe_file.txt' is not a safe relative path"):
            self.file_processor.parseStructuredOutput(code_block, format='json')

        # Verify file content remains unchanged
        with open(self.initial_file_abs_path, 'r', encoding='utf-8') as f:
            self.assertEqual(f.read(), self._INITIAL_FILE_CONTENT, "File content should be unchanged after unsafe path error")

        # Verify repo is not dirty
        self.assertFalse(self.github_handler.isDirty(self.local_repo_path), "Repo should be clean after unsafe path error")

    @patch('core.github_handler.GitHubHandler.cloneRepository')
    # No LLM mock needed for this test
    def test_workflow_file_read_error(
        self: 'TestCoreIntegration',
        mock_cloneRepository: MagicMock
    ) -> None:
        """Tests workflow handling when reading a selected file fails (e.g., file deleted)."""
        # --- Arrange ---
        mock_cloneRepository.return_value = self.repo
        repo_loaded = self.github_handler.cloneRepository(self._MOCK_URL, self.local_repo_path)
        selected_files = ["non_existent_file.txt"] # Simulate selecting a file that doesn't exist

        # --- Act & Assert ---
        # Expect GitHubError when attempting to read the non-existent file
        with self.assertRaisesRegex(GitHubError, "File not found at calculated path"):
            # This loop simulates what the FileWorker or main logic might do
            for f_path in selected_files:
                self.github_handler.readFileContent(self.local_repo_path, f_path)

        # Verify repo is not dirty (as no changes were made)
        self.assertFalse(self.github_handler.isDirty(self.local_repo_path), "Repo should be clean after file read error")


    @patch('core.github_handler.GitHubHandler.cloneRepository')
    @patch('core.llm_interface.LLMInterface.queryLlmApi')
    @patch('core.file_processor.FileProcessor.saveFilesToDisk') # Mock saving specifically
    def test_workflow_file_save_error(
        self: 'TestCoreIntegration',
        mock_saveFilesToDisk: MagicMock,
        mock_queryLlmApi: MagicMock,
        mock_cloneRepository: MagicMock
    ) -> None:
        """Tests workflow handling when saving files fails (e.g., permissions)."""
        # --- Arrange ---
        mock_cloneRepository.return_value = self.repo
        mock_llm_response_json = { self._INITIAL_FILE_REL_PATH: self._UPDATED_FILE_CONTENT }
        mock_llm_response_text = f"```json\n{json.dumps(mock_llm_response_json)}\n```"
        mock_queryLlmApi.return_value = mock_llm_response_text
        # Simulate saveFilesToDisk raising an error
        save_error_message = "Permission denied writing file"
        mock_saveFilesToDisk.side_effect = FileProcessingError(save_error_message)

        # --- Act ---
        repo_loaded = self.github_handler.cloneRepository(self._MOCK_URL, self.local_repo_path)
        # FIX: Call queryLlmApi without apiKey argument
        llm_response = self.llm_interface.queryLlmApi("prompt", self._MOCK_MODEL_NAME)
        code_block = self.file_processor.extractCodeBlock(llm_response, language='json')
        parsed_data = self.file_processor.parseStructuredOutput(code_block, format='json')

        # --- Assert ---
        # Expect FileProcessingError when attempting to save
        with self.assertRaisesRegex(FileProcessingError, save_error_message):
            self.file_processor.saveFilesToDisk(self.local_repo_path, parsed_data)

        # Verify saveFilesToDisk was called
        mock_saveFilesToDisk.assert_called_once_with(self.local_repo_path, parsed_data)

        # Verify file content remains unchanged (assuming error prevents partial writes)
        with open(self.initial_file_abs_path, 'r', encoding='utf-8') as f:
            self.assertEqual(f.read(), self._INITIAL_FILE_CONTENT, "File content should be unchanged after save error")

        # Verify repo is not dirty (assuming error prevents changes)
        self.assertFalse(self.github_handler.isDirty(self.local_repo_path), "Repo state uncertain after save error, ideally should be checked.")


    @patch('core.github_handler.GitHubHandler.cloneRepository')
    @patch('core.llm_interface.LLMInterface.queryLlmApi')
    @patch('core.github_handler.GitHubHandler.updateRepo') # Mock commit/push
    def test_workflow_commit_push_error_rejected(
        self: 'TestCoreIntegration',
        mock_updateRepo: MagicMock,
        mock_queryLlmApi: MagicMock,
        mock_cloneRepository: MagicMock
    ) -> None:
        """Tests workflow handling when commit/push fails (e.g., rejected due to remote changes)."""
        # --- Arrange ---
        mock_cloneRepository.return_value = self.repo
        mock_llm_response_json = { self._INITIAL_FILE_REL_PATH: self._UPDATED_FILE_CONTENT }
        mock_llm_response_text = f"```json\n{json.dumps(mock_llm_response_json)}\n```"
        mock_queryLlmApi.return_value = mock_llm_response_text
        # Simulate updateRepo raising a GitHubError for rejection
        push_error_message = "Push rejected. Remote branch .* has changes not present locally"
        mock_updateRepo.side_effect = GitHubError(push_error_message)

        # --- Act ---
        repo_loaded = self.github_handler.cloneRepository(self._MOCK_URL, self.local_repo_path)
        # FIX: Call queryLlmApi without apiKey argument
        llm_response = self.llm_interface.queryLlmApi("prompt", self._MOCK_MODEL_NAME)
        code_block = self.file_processor.extractCodeBlock(llm_response, language='json')
        parsed_data = self.file_processor.parseStructuredOutput(code_block, format='json')
        self.file_processor.saveFilesToDisk(self.local_repo_path, parsed_data) # Real save

        # Verify repo is dirty before attempting push
        self.assertTrue(self.github_handler.isDirty(self.local_repo_path), "Repo should be dirty before push attempt")

        # --- Assert ---
        # Expect GitHubError when attempting to push
        with self.assertRaisesRegex(GitHubError, push_error_message):
            self.github_handler.updateRepo(
                self.local_repo_path, self._COMMIT_MSG, push=True, remoteName=self._REMOTE_NAME, branchName=self._BRANCH_NAME
            )

        # Verify updateRepo was called
        mock_updateRepo.assert_called_once_with(
            self.local_repo_path, self._COMMIT_MSG, push=True, remoteName=self._REMOTE_NAME, branchName=self._BRANCH_NAME, progress_handler=None
        )

        # Verify repo remains dirty locally after failed push
        self.assertTrue(self.github_handler.isDirty(self.local_repo_path), "Repo should remain dirty after failed push")
        # Verify commit was made locally (check HEAD)
        self.assertEqual(self.repo.head.commit.message.strip(), self._COMMIT_MSG.strip(), "Local commit message mismatch after failed push")


if __name__ == '__main__':
    unittest.main()

# --- END: tests/test_integration.py ---